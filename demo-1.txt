# System Design Document: Financial Institutions Search Using AWS OpenSearch Service

## 1. Introduction

### 1.1 Purpose
This document outlines the design for a search system that enables users to query financial institutions via a UI, retrieving paginated results from AWS OpenSearch Service. The system prioritizes popular banks (e.g., Chase, Wells Fargo, Citi, Bank of America) by ranking them higher in search results when they match the user's search terms. The response format follows the provided sample JSON structure, ensuring compatibility with the UI.

### 1.2 Scope
- Indexing financial institutions data in OpenSearch.
- Implementing search queries with pagination and boosting for popular institutions.
- Generating responses in the specified JSON format.
- Assumptions: Data is provided in JSON format similar to the sample; the system handles up to 10,000 institutions; UI interacts via an API endpoint (e.g., AWS Lambda or API Gateway proxying OpenSearch).

### 1.3 References
- AWS OpenSearch Service Documentation: https://docs.aws.amazon.com/opensearch-service/latest/developerguide/what-is.html
- Elasticsearch Query DSL (basis for OpenSearch): https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html

## 2. Requirements

### 2.1 Functional Requirements
- **Search Functionality**: Users enter search terms (e.g., "chase") in the UI, which triggers a search on institution names.
- **Pagination**: Results are paginated (e.g., 10 items per page), with metadata indicating total found, displayed, and if more are available.
- **Ranking**: Popular banks (Chase, Wells Fargo, Citi, Bank of America) rank first among matching results. Other institutions rank based on relevance.
- **Response Format**: JSON object with keys: `found` (total matches), `displaying` (results in this page), `moreAvailable` (boolean), `createdDate` (Unix timestamp of index creation or query time), `institutions` (array of matching institution objects).
- **Data Fields**: Each institution includes fields as in the sample (id, name, booleans like transAgg, contact info, address, branding, etc.).

### 2.2 Non-Functional Requirements
- **Performance**: Search latency < 500ms for 95% of queries; handle 100 QPS.
- **Scalability**: OpenSearch cluster with at least 2 data nodes for redundancy.
- **Security**: Use IAM roles for access; fine-grained access control if needed.
- **Reliability**: Data indexed with replicas; handle failures via retries in the API layer.

## 3. Architecture Overview

### 3.1 High-Level Components
- **Data Source**: JSON files or a database (e.g., S3 or DynamoDB) containing institution data.
- **Ingestion Pipeline**: AWS Lambda or Glue job to index data into OpenSearch using Bulk API.
- **Search API**: AWS API Gateway + Lambda to handle UI requests, construct OpenSearch queries, and format responses.
- **OpenSearch Domain**: Managed AWS service for indexing and searching.
- **UI Integration**: Frontend sends GET/POST requests to the API with parameters: `query` (search term), `page` (pagination), `size` (items per page, default 10).

### 3.2 Data Flow
1. Data is ingested from source to OpenSearch index.
2. User submits search via UI → API Gateway → Lambda.
3. Lambda builds OpenSearch query, executes via AWS SDK.
4. OpenSearch returns hits; Lambda formats into JSON response.
5. UI displays results, handles pagination.

## 4. Index Design

### 4.1 Index Name
- `financial-institutions`

### 4.2 Mapping
The mapping defines document structure. Use dynamic mapping with explicit types for key fields. Add a custom field `is_popular` (boolean) to flag popular institutions during ingestion (true for Chase, Wells Fargo, Citi, Bank of America based on name matching).

Example mapping (PUT /financial-institutions/_mapping):

```json
{
  "properties": {
    "id": { "type": "integer" },
    "name": { 
      "type": "text", 
      "fields": { "keyword": { "type": "keyword" } } 
    },
    "transAgg": { "type": "boolean" },
    "ach": { "type": "boolean" },
    "stateAgg": { "type": "boolean" },
    "voi": { "type": "boolean" },
    "voa": { "type": "boolean" },
    "aha": { "type": "boolean" },
    "availBalance": { "type": "boolean" },
    "accountOwner": { "type": "boolean" },
    "studentLoanData": { "type": "boolean" },
    "loanPaymentDetails": { "type": "boolean" },
    "accountTypeDescription": { "type": "text" },
    "phone": { "type": "keyword" },
    "urlHomeApp": { "type": "keyword" },
    "urlLogonApp": { "type": "keyword" },
    "oauthEnabled": { "type": "boolean" },
    "urlForgotPassword": { "type": "keyword" },
    "urlOnlineRegistration": { "type": "keyword" },
    "class": { "type": "keyword" },
    "specialText": { "type": "text" },
    "timeZone": { "type": "keyword" },
    "specialInstructions": { "type": "text" },
    "specialInstutionsTitle": { "type": "text" },
    "address": {
      "properties": {
        "city": { "type": "keyword" },
        "state": { "type": "keyword" },
        "country": { "type": "keyword" },
        "postalCode": { "type": "keyword" },
        "addressLine1": { "type": "text" },
        "addressLine2": { "type": "text" }
      }
    },
    "currency": { "type": "keyword" },
    "email": { "type": "keyword" },
    "status": { "type": "keyword" },
    "newInstitutionId": { "type": "integer" },
    "branding": {
      "properties": {
        "logo": { "type": "keyword" },
        "alternateLogo": { "type": "keyword" },
        "icon": { "type": "keyword" },
        "primaryColor": { "type": "keyword" },
        "tile": { "type": "keyword" }
      }
    },
    "oauthInstitutionId": { "type": "integer" },
    "is_popular": { "type": "boolean" }
  }
}
```

### 4.3 Ingestion
- Use AWS Lambda triggered by S3 upload or scheduled.
- Script: Read JSON data, add `is_popular` based on name containing "chase", "wells fargo", "citi", "bank of america" (case-insensitive).
- Bulk index using OpenSearch Bulk API.
- Set `createdDate` as a index-level setting or document field if needed (e.g., ingestion timestamp).

## 5. Search Query Design

### 5.1 Query Structure
Use Function Score Query to boost popular institutions. Base search on `name` field using multi_match for fuzzy/partial matches.

Example OpenSearch query (POST /financial-institutions/_search):

```json
{
  "from": 0,  // (page - 1) * size
  "size": 10,
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query": "user_search_term",
          "fields": ["name"],
          "fuzziness": "AUTO"  // For partial matches
        }
      },
      "functions": [
        {
          "filter": {
            "term": { "is_popular": true }
          },
          "weight": 100  // Boost popular matches significantly
        }
      ],
      "score_mode": "sum",  // Add boost to base relevance score
      "boost_mode": "replace"  // Use the combined score
    }
  }
}
```

- **Boosting Logic**: Popular institutions get an additional 100 to their score, ensuring they rank above non-popular matches with similar relevance.
- **Pagination**: `from` and `size` control paging.
- **Edge Cases**: If no query, return all (or top popular). Handle empty results.

### 5.2 Response Formatting
In Lambda:
- `found = response['hits']['total']['value']`
- `displaying = len(response['hits']['hits'])`
- `moreAvailable = (from + size < found)`
- `createdDate = int(time.time())`  // Or fixed/index creation time
- `institutions = [hit['_source'] for hit in response['hits']['hits']]`
- Remove internal fields like `is_popular` if present.

Output matches sample JSON.

## 6. Implementation Details

### 6.1 AWS Setup
- Create OpenSearch domain: t3.small.search instances, 2 data nodes, enable UltraWarm if cold storage needed.
- VPC for security; access via IAM policy.
- Monitoring: Enable CloudWatch metrics for search latency, indexing rate.

### 6.2 API Layer (Lambda)
- Python/Node.js handler.
- Use `opensearch-py` or AWS SDK to sign requests.
- Input: query params `q`, `page`, `size`.
- Error Handling: Retry on timeouts; return 400 for invalid params.

### 6.3 Testing
- Unit: Query syntax, boosting logic.
- Integration: End-to-end search with sample data.
- Load: Simulate 100 QPS.
- Scenarios: Exact match on popular (ranks first), partial match, pagination boundaries.

## 7. Risks and Mitigations
- **Data Freshness**: Schedule re-indexing daily; mitigate with incremental updates.
- **Cost**: Monitor usage; use reserved instances.
- **Security**: Encrypt data at rest; restrict API access.
- **Scalability**: Auto-scale Lambda; add OpenSearch nodes as needed.

## 8. Appendix
- Popular Banks List: ["chase", "wells fargo", "citi", "bank of america"] (case-insensitive match during ingestion).
- Future Enhancements: Search on additional fields (e.g., city), faceting for filters (e.g., by class).
